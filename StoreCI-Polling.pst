<?xml version="1.0"?><st-source><!-- Name: StoreCI-PollingNotice: The MIT LicenseCopyright (c) 2012 - 2013 , Randy CoulmanPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Comment: # StoreCIIntegrate Cincom Visualworks Smalltalk with a Continuous Integration server.StoreCI is licensed under the MIT license.  See the Copyright tab in the RB, the 'notice' property of this package, or the License.txt file on GitHub.StoreCI's primary home is the [Cincom Public Store Repository](http://www.cincomsmalltalk.com/CincomSmalltalkWiki/Public+Store+Repository).  Check there for the latest version.  It is also on [GitHub](https://github.com/randycoulman/StoreCI).StoreCI was developed in VW 7.9.1, but is compatible with VW 7.7 and later.  It uses the newer Glorp-based Store implementation, so will not work in 7.6 or earlier.  If you find any incompatibilities with VW 7.7 or later, let me know (see below for contact information) or file an issue on GitHub.# StoreCI-PollingStoreCI-Polling is a bridge between a Continuous Integration (CI) server and Visualworks Store.  It has been tested against Jenkins 1.466 and later using the [visualworks-store-plugin](https://wiki.jenkins-ci.org/display/JENKINS/Visualworks+Smalltalk+Store+Plugin).## UsageThe Jenkins visualworks-store-plugin expects to run StoreCI-Polling by invoking a shell script (or batch file on Windows).  This script should run Visualworks with an image that has StoreCI-Polling already loaded, or with a base image and command-line options to load StoreCI-Polling from a parcel.  The image also needs to contain Store repository definitions for the repositories that you want to monitor, or you can use the `-repositoriesFrom` argument (see `ImportRepositoriesSubsystem` in StoreCI-Support).The script should pass any command-line arguments that it receives on to the image.  An example Unix/Linux/MacOS shell script might run StoreCI-Polling this way:	/path/to/VM /path/to/image "$@"or:	/path/to/VM /path/to/image -pcl /path/to/StoreCI-Polling.pcl "$@"## Configuring the Jenkins Pluginvisualworks-store-plugin contains a global configuration section (under the Manage Jenkins link) where you can define one or more scripts as described above.  Simply specify the full path to the desired script.  You might have multiple scripts if you want to run builds for multiple versions of Visualworks in parallel.When creating or editing a Job, you can choose Store as the SCM type.  Then:* Choose one of the scripts you configured in the global settings.* Specify the name of the Store repository to monitor.* Choose one or more pundles to monitor.  StoreCI-Polling will watch for changes to those pundles and any of their (recursive) prerequisites in the same repository.  Thus, it is only necessary to specify "root" pundles here.* Specify a regular expression that indicates what versions you would like to consider.  By default, all versions are considered.  The regular expression must be in Regex11 format.  For example, integer-only version numbers can be matched using `\d+`.* Specify a minimum blessing level (default: Development).  Pundles with a lower blessing level will not be considered.* If desired, check the box to enable generation of an input file for ParcelBuilder (now called StoreCI-Building) and then specify a filename.  This file will contain the list of most-recent pundle versions that were found by StoreCI-Polling as of the time the build started.  This file can be used by StoreCI-Building or similar tool to build an image or deploy parcels as part of the build.  If no path is specified, the file will be created in the root of the Jenkins workspace directory for your project.  This file will contain the pundles in "load order".  That is, all of a pundle's prerequisites will be earlier in the file than itself.  That way, when loading the pundles into an image, no automatic prerequisite resolution will need to be done.The visualworks-store-plugin is designed to work with the Multiple SCMs plugin.  This is useful if you need to monitor more than one repository for the same build, or if you need to monitor both a Store repository and a git or Subversion repository.## Command-line UsageIf you'd like to use StoreCI-Polling with a different CI system, you'd need to configure that system to invoke StoreCI-Polling with the correct command-line arguments.StoreCI-Polling has two basic modes of operation:1. Compute the current revision state.  This is what a CI system uses to determine whether there are any source code changes that should trigger a build.2. Compute a changelog.  This is what a CI system uses to report the details of any changes.They both write the current revision state to Stdout to be picked up by the CI system.  That allows some optimizations in the CI system, and also provides for CI systems that only invoke a single operation - they can use the changelog-computation operation.  See the RevisionState class comment for details on the output format.Both operations accept the following command-line arguments:* (Optional) `-repositoriesFrom <Filename>`: The name of a file containing the necessary Store repository definitions.  See `ImportRepositoriesSubsystem` in StoreCI-Support for more information.* (Required) `-repository <Name>`: The name of the Store repository to monitor.  The image containing StoreCI-Polling must have a repository defined with this name.* (Required) `-package <Package name>` / `-packages <list of Package Names>` / `-bundle <Bundle name>` / `-bundles <list of Bundle names>`: The "root" pundles to monitor.  StoreCI-Polling monitors these pundles and their recursive prerequisites for changes.* (Optional) `-blessedAtLeast <Blessing Level>`: The minimum blessing level that will be considered.  Pundles with a lower blessing level will be ignored.* (Optional) `-versionRegex <Regex>`: A Regex11-style regular expression that can be used to specify which versions of pundles should be considered.* (Optional) `-parcelBuilderFile <Filename>`: The name of a file that StoreCI-Polling will populate with the current versions of all of the pundles considered.  This file will contain the pundles in "load order".  That is, all of a pundle's prerequisites will be earlier in the file than itself.  That way, when loading the pundles into an image, no automatic prerequisite resolution will need to be done.  See the `LoadOrder` class comment for details on the file format.* (Optional) `-debug`: When specified, exceptions will not be trapped and the image will not exit upon completion.The changelog computation process also takes:* (Required) `-changelog <Filename>`: The name of the file to which the changelog should be written.  See the `Changelog` class comment for details on the file format.* (Required) `-since <Timestamp>`: The time of the previous build.  The timestamp must be formatted in the C-locale timestamp format compatible with `Timestamp class>>readFrom:`.* (Required) `-now <Timestamp>`: The time of the current build.  The timestamp must be formatted in the C-locale timestamp format compatible with `Timestamp class>>readFrom:`.  By specifying this timestamp, any changes that are published while the current build is running will be ignored and then picked up on the next build cycle.Revision state is computed without making any changes to the local filesystem.  Thus, it can be run from any working directory.Changelog computation, however, maintains a cache of the last-seen pundle versions in a .store subdirectory of the working directory.  This allows it to determine which packages are new, deleted, or just modified.## Understanding the Code`PollingSubsystem` is the main entry point for the command-line application.  It processes command-line arguments, configures an instance of `StoreSCM`, and then invokes the desired operation on it.  See the class and method comments for more information.## Related WorkStoreCI-Polling could also work with CruiseControl, but would require some changes to the CruiseControl Store plugin to support bundles and the new command-line API.  See my older CruiseControl package in the Public Store Repository.  The CruiseControl package supports the command-line API used by the CruiseControl Store plugin, but only supports packages and not bundles at this time.# ContributingI'm happy to receive bug fixes and improvements to this package.  If you'd like to contribute, please publish your changes as a "branch" (non-integer) version in the Public Store Repository and contact me as outlined below to let me know.  I will merge your changes back into the "trunk" as soon as I can review them.# Contact InformationIf you have any questions about this package and how to use it, feel free to contact me.* Web site: http://randycoulman.com* Blog: Courageous Software (http://randycoulman.com/blog)* E-mail: randy _at_ randycoulman _dot_ com* Twitter: @randycoulman* GitHub: randycoulmanDbIdentifier: /Users/randy/repositories/store/RCSmalltalkDbTrace: 1453DbUsername: randyDbVersion: 55DevelopmentPrerequisites: #(#(#any 'Base VisualWorks' '') #(#any 'StoreCI-Support' '') #(#any 'StoreBase' '') #(#any 'Glorp' '') #(#any 'Regex11' ''))DisregardedPrerequisites: #(#(#name 'Collections-Collation' #componentType #package))Namespace: StoreCI.PollingPackageName: StoreCI-PollingParcel: #('StoreCI-Polling')PrerequisiteDescriptions: #(#(#name 'Base VisualWorks' #componentType #bundle) #(#name 'StoreCI-Support' #componentType #package) #(#name 'StoreBase' #componentType #bundle) #(#name 'Glorp' #componentType #bundle) #(#name 'Regex11' #componentType #package #explicit true))PrerequisiteParcels: #(#('Base VisualWorks' '') #('StoreCI-Support' '') #('StoreBase' '') #('Glorp' '') #('Regex11' ''))PrintStringCache: (55,randy)Version: 55Date: 6:44:36 PM April 17, 2013 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 7.9.1 of October 18, 2012 on April 17, 2013 at 6:44:36 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Polling</name><environment>StoreCI</environment><private>false</private><imports>			private Smalltalk.*			private XML.*			private StoreCI.Support.*			private Store.Glorp.*			</imports><category></category><attributes><package>StoreCI-Polling</package></attributes></name-space><class><name>Changelog</name><environment>StoreCI.Polling</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>knownPundles pundles deletedPundles </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><comment><class-id>StoreCI.Polling.Changelog</class-id><body>Changelog tracks the changed versions of all relevant pundles and writes the changelog file used by the CI system.It uses a KnownPundleCache to determine if a pundle is new or just modified.The changelog is assembled by sends of #addPundles:, #noteDeletedPundles:, and #noteHeadRevision:.  Head revisions are only included in the changelog for pundles not in the KnownPundleCache.  This happens when a pundle gets a new prerequisite, for example.The changelog is written as XML.&lt;log&gt;	&lt;package name="Name" version="Version" action="{added | modified | deleted}"&gt;		&lt;blessing user="Username" timestamp="C-Locale format timestamp"&gt;			Blessing comment.		&lt;/blessing&gt;	&lt;/package&gt;	&lt;bundle ...same as for package...&gt;	...&lt;/log&gt;The blessings are listed in order from newest to oldest.  Note that deleted pundles (those with action="deleted") will not have a version attribute or any nested blessing elements.Instance Variables	deletedPundles	&lt;(Collection of: PundleSpec)&gt;	Pundles which are no longer used since the previous build.	knownPundles	&lt;KnownPundleCache&gt;	Cache of pundles from the previous build.	pundles	&lt;Collection of: StorePundle&gt;	Pundles which are new or changed since the previous build.</body></comment><class><name>KnownPundleCache</name><environment>StoreCI.Polling</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename knownPundles </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><comment><class-id>StoreCI.Polling.KnownPundleCache</class-id><body>KnownPundleCache represents a list of pundles from a previous build.  The cache is backed by a file on disk that persists between builds.  KnownPundleCache works with PundleSpecs.Instance Variables	filename	&lt;Filename&gt;	The file that backs the cache.	knownPundles	&lt;Set&gt;	The PundleSpecs from the previous build.</body></comment><class><name>StoreSCM</name><environment>StoreCI.Polling</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parcelBuilderInputFile storeInterface knownPundles revisionState changelog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><comment><class-id>StoreCI.Polling.StoreSCM</class-id><body>StoreSCM is the main domain class for StoreCI.  An instance of StoreSCM is configured by StoreCISystem and then invoked using one of its two actions:* #writeRevisionStateTo:* #writeChangesFrom:to:toFile:revisionStateTo:StoreSCM coordinates the necessary activity amongst its collaborators and is responsible for very little of the work itself.Instance Variables	changelog	&lt;Changelog&gt;	Changelog computes and writes the list of changed pundle versions; unused when just computing revision state.	knownPundles	&lt;KnownPundleCache&gt;	The list of pundles seen during the previous build; unused when just computing revision state.  This information is read from a file in the .store subdirectory of the working directory.	parcelBuilderInputFile	&lt;Filename&gt;	The file to write the pundle load order to.  If nil, don't write the load order.  See LoadOrder for details.	revisionState	&lt;RevisionState&gt;	The list of "head" versions of all of the pundles.  This list includes bundles and their components.	storeInterface	&lt;StoreInterface&gt;	The object that performs Store queries on our behalf.</body></comment><class><name>RevisionState</name><environment>StoreCI.Polling</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>roots visited revisions bundleRevisions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><comment><class-id>StoreCI.Polling.RevisionState</class-id><body>RevisionState computes and remembers the latest applicable version of each pundle of interest.To compute the revision state, it starts from a list of root pundles and traverses their pre-reqs and bundle contents until it hits leaf pundles or pundles not in the repository.  It relies on the block passed into #computeWith: to actually find the desired pundle versions.  RevisionState also creates a LoadOrder when asked.  LoadOrder requires the full list of revisions in the RevisionState, but also needs a dictionary that maps bundles to their subset of the RevisionState (that is, all pundles reachable from that bundle).  Note that these bundleRevisions only include pundles that were encountered for the first time when processing that bundle; pundles that were visited earlier in the enumeration are not included.  This limitation meets LoadOrder's needs, but may potentially surprise other future clients.The RevisionState can also be written to a stream.  Each Pundle is written to the stream, one per line, in the following format:PundleClassName&lt;tab&gt;"Name in Double Quotes"&lt;tab&gt;PundleVersionInstance Variables	bundleRevisions	&lt;Dictionary&gt;	Map of Bundles to a collection of Pundles first encountered when traversing from that Bundle.	revisions	&lt;(Collection of: StorePundle)&gt;	The "head" version of every Pundle reachable from roots via pre-requisites or bundle contents.	roots	&lt;Collection of: PundleSpec)&gt;	PundleSpecs representing the top-most pundles of interest.	visited	&lt;Set of: PundleSpec&gt;	All PundleSpecs seen during traversal; this keeps us from processing the same pundles over and over.</body></comment><class><name>BlessingNotFound</name><environment>StoreCI.Polling</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><comment><class-id>StoreCI.Polling.BlessingNotFound</class-id><body>Raised when the blessing name specified on the command-line could not be found in the current blessing policy's list of known blessings.</body></comment><class><name>PollingSubsystem</name><environment>StoreCI.Polling</environment><super>StoreCI.Support.StoreCISubsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rootPundles versionMatcher minimumBlessingLevel repository parcelBuilderInputFile outputStream lastBuildTime currentTime changelogFile </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><comment><class-id>StoreCI.Polling.PollingSubsystem</class-id><body>PollingSubsystem is the main command-line entry point for StoreCI-Polling.  See the package comment for details on usage and command-line options.PollingSubsystem is designed to be inert unless it is given a repository name and at least one root pundle.  If those are provided, then it checks for the presence of the changelog filename and build times.  If any of those three arguments are provided, it assumes that it needs to compute a changelog, but if not all of the three are provided, it raises a ValidationError.  The idea is that, if any of the three arguments are provided, the user is trying to compute a changelog, but may not have got the parameter usage correct, so we tell them about it rather than just assuming that they wanted the revision state.Once PollingSubsystem determines which operation to perform, it configures an instance of StoreSCM and invokes the desired operation.Instance Variables	changelogFile	&lt;Filename&gt;	The name of the file to which the changelog should be written.  See Changelog for details.	currentTime	&lt;Timestamp&gt;	The time of the current build.  Changes from after this timestamp will be ignored until the next build cycle.	debug	&lt;Boolean&gt;	When set, exceptions will not be trapped, and the image will not exit automatically upon completion.  Default: false.	errorStream	&lt;WriteStream&gt;	A stream on which to write information about any errors that occur.  Default: Stderr.	lastBuildTime	&lt;Timestamp&gt;	The time of the previous build.  Changes from before this timestamp will be ignored.  They were part of a previous build cycle.	minimumBlessingLevel	&lt;Integer&gt;	The minimum blessing level to consider.  Pundle versions with a lower level are ignored.  Default: 20 (Development).	outputStream	&lt;WriteStream&gt;	A stream on which to write the revision state.  See RevisionState for details. Default: Stdout.	parcelBuilderInputFile	&lt;Filename or nil&gt;	The name of a file in which to write the pundle load order.  See LoadOrder for details.  Default: nil (Don't write a file).	repository	&lt;Store.ConnectionProfile&gt;	The Store connection profile for the repository to monitor.	rootPundles	&lt;OrderedCollection of PundleSpec&gt;	The list of root pundles to monitor.	versionMatcher	&lt;Regex11.RxMatcher&gt;	Used to match pundle versions to determine if they should be considered or not.</body></comment><class><name>LoadOrder</name><environment>StoreCI.Polling</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>revisions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><comment><class-id>StoreCI.Polling.LoadOrder</class-id><body>LoadOrder represents the current list of pundle versions in "load order" - that is, the order they should be loaded into a new image such that we don't rely on Store to do prerequisite resolution for us.In the absence of bundles, LoadOrder's revisions and RevisionState's revisions are identical.  However, with bundles, RevisionState contains all of the pundles, including bundle components, but LoadOrder does not; it contains only the containing bundle.A LoadOrder is typically constructed by a RevisionState with the full list of revisions, plus a Dictionary that maps bundles to their reachable subset of the revisions.  LoadOrder computes its revisions from those two pieces of information at construction time.  To compute the load order, it is not sufficient to just remove all bundle components from the full list of revisions, because it is possible for a pundle earlier in the list to depend on one of the bundle components that was just removed.  Thus, it is also necessary to move the bundle forward in the list to the position of its earliest component.  For this to work, it is also necessary to move all of that bundle's prerequisites forward in the list with it.  The bundleRevisions Dictionary is what contains the information that allows this to happen.The LoadOrder can be written to a stream.  Each Pundle is written to the stream, one per line, in the following format:PundleClassName&lt;tab&gt;"Name in Double Quotes"&lt;tab&gt;PundleVersionInstance Variables	revisions	&lt;OrderedCollection&gt;	The list of current revisions, in the order they should be loaded.</body></comment><class><name>StoreInterface</name><environment>StoreCI.Polling</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session minimumBlessingLevel versionMatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><comment><class-id>StoreCI.Polling.StoreInterface</class-id><body>StoreInterface is StoreCI's interface to the Store repository.  It is responsible for performing the actual queries needed by StoreSCM.Instance Variables	minimumBlessingLevel	&lt;SmallInteger&gt;	Only pundles with this blessing level or higher are considered.	session	&lt;GlorpSession&gt;	The database session to use for queries.	versionMatcher	&lt;RxMatcher&gt;	Only pundle versions that match this regular expression matcher are considered.</body></comment><class><name>ValidationError</name><environment>StoreCI.Polling</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Polling</package></attributes></class><comment><class-id>StoreCI.Polling.ValidationError</class-id><body>Raised when an incomplete or inconsistent set of command-line arguments are provided.</body></comment><methods><class-id>StoreCI.Polling.Changelog</class-id> <category>private - test support</category><body package="StoreCI-Polling">addPundle: aStorePundle	pundles add: aStorePundle</body><body package="StoreCI-Polling">includes: aStorePundle	^pundles includes: aStorePundle</body><body package="StoreCI-Polling">isEmpty	^pundles isEmpty and: [deletedPundles isEmpty]</body><body package="StoreCI-Polling">noteDeletedPundle: aPundleSpec	deletedPundles add: aPundleSpec</body></methods><methods><class-id>StoreCI.Polling.Changelog</class-id> <category>accessing</category><body package="StoreCI-Polling">size	^pundles size</body></methods><methods><class-id>StoreCI.Polling.Changelog</class-id> <category>initialize-release</category><body package="StoreCI-Polling">initializeKnownPundles: aKnownPundles	knownPundles := aKnownPundles.	pundles := OrderedSet new.	deletedPundles := OrderedSet new</body></methods><methods><class-id>StoreCI.Polling.Changelog</class-id> <category>writing</category><body package="StoreCI-Polling">writeToFile: aFilename	| ws |	ws := aFilename writeStream.	[self writeToStream: ws] ensure: [ws close]</body><body package="StoreCI-Polling">writeToStream: aStream	aStream		nextPutAll: '&lt;?xml version="1.0"?&gt;';		cr.	self asXML printOn: aStream.	aStream flush</body></methods><methods><class-id>StoreCI.Polling.Changelog</class-id> <category>adding</category><body package="StoreCI-Polling">addPundles: aCollection	aCollection do: [:each | self addPundle: each]</body><body package="StoreCI-Polling">noteDeletedPundles: aCollection	aCollection do: [:each | self noteDeletedPundle: each]</body><body package="StoreCI-Polling">noteHeadRevision: aStorePundle	"Head revisions are only interesting for pundles that are new since the previous build."	aStorePundle ifNil: [^self].	(self isNewPundle: aStorePundle) ifFalse: [^self].	self addPundle: aStorePundle</body></methods><methods><class-id>StoreCI.Polling.Changelog</class-id> <category>private</category><body package="StoreCI-Polling">actionForPundle: aStorePundle	(self isDeletedPundle: aStorePundle) ifTrue: [^'deleted'].	(self isNewPundle: aStorePundle) ifTrue: [^'added'].	^'modified'</body><body package="StoreCI-Polling">asXML	| root |	root := Element tag: 'log'.	(pundles asSortedCollection: [:a :b | a timestamp &gt;= b timestamp])		do: [:each | root addNode: (self xmlElementForPundle: each)].	deletedPundles		do: [:each | root addNode: (self xmlElementForPundle: each)].	^(XML.Document new)		addNode: root;		yourself</body><body package="StoreCI-Polling">isDeletedPundle: aPundleSpec	^deletedPundles includes: aPundleSpec</body><body package="StoreCI-Polling">isNewPundle: aStorePundle	^(knownPundles includes: aStorePundle asStoreCIPundleSpec) not</body><body package="StoreCI-Polling">xmlElementForPundle: aStorePundleOrSpec	| action |	action := self actionForPundle: aStorePundleOrSpec.	^(aStorePundleOrSpec asXMLElementForStoreCI)		addAttribute: (Attribute name: 'action' value: action);		yourself</body></methods><methods><class-id>StoreCI.Polling.Changelog class</class-id> <category>instance creation</category><body package="StoreCI-Polling">knownPundles: aKnownPundles	^self new initializeKnownPundles: aKnownPundles</body></methods><methods><class-id>StoreCI.Polling.KnownPundleCache</class-id> <category>initialize-release</category><body package="StoreCI-Polling">initializeCache: aCollection	knownPundles := Set withAll: aCollection</body><body package="StoreCI-Polling">initializeFilename: aFilename	filename := aFilename.	knownPundles := Set new</body></methods><methods><class-id>StoreCI.Polling.KnownPundleCache</class-id> <category>accessing</category><body package="StoreCI-Polling">pundlesMissingFrom: aCollection	"Return any cached pundles that are not in aCollection."	^(knownPundles - aCollection) asSet</body><body package="StoreCI-Polling">size	^knownPundles size</body></methods><methods><class-id>StoreCI.Polling.KnownPundleCache</class-id> <category>testing</category><body package="StoreCI-Polling">includes: aPundleSpec	^knownPundles includes: aPundleSpec versionless</body><body package="StoreCI-Polling">isEmpty	^knownPundles isEmpty</body></methods><methods><class-id>StoreCI.Polling.KnownPundleCache</class-id> <category>loading-saving</category><body package="StoreCI-Polling">load	"Load the cache from disk."	| rs |	filename exists ifFalse: [^self].	rs := filename readStream.	[knownPundles addAll: (PundleSpec allFrom: rs)] ensure: [rs close]</body><body package="StoreCI-Polling">updateWithPundles: aCollection	"Update our list of known pundles and write them to our disk store."	knownPundles := Set withAll: aCollection.	self writeCacheWith: aCollection</body></methods><methods><class-id>StoreCI.Polling.KnownPundleCache</class-id> <category>private</category><body package="StoreCI-Polling">writeCacheWith: aCollection	| ws |	filename directory ensureDirectory.	ws := filename writeStream.	[PundleSpec writeAll: aCollection to: ws] ensure: [ws close]</body></methods><methods><class-id>StoreCI.Polling.KnownPundleCache class</class-id> <category>instance creation</category><body package="StoreCI-Polling">filename: aFilename	^self new initializeFilename: aFilename asFilename</body><body package="StoreCI-Polling">withAll: aCollection	^self new initializeCache: aCollection</body></methods><methods><class-id>StoreCI.Polling.StoreSCM</class-id> <category>initialize-release</category><body package="StoreCI-Polling">initializeRepository: aConnectionProfile rootPundles: aCollection minimumBlessingLevel: anInteger	| cacheFilename |	storeInterface := StoreInterface connectionProfile: aConnectionProfile				minimumBlessingLevel: anInteger.	revisionState := RevisionState roots: aCollection.	cacheFilename := '.store' asFilename				/ ('previousPackages.' , aConnectionProfile name).	knownPundles := KnownPundleCache filename: cacheFilename.	changelog := Changelog knownPundles: knownPundles</body><body package="StoreCI-Polling">parcelBuilderInputFile: aFilenameOrNil	parcelBuilderInputFile := aFilenameOrNil</body><body package="StoreCI-Polling">versionMatcher: anRxMatcher	storeInterface versionMatcher: anRxMatcher</body></methods><methods><class-id>StoreCI.Polling.StoreSCM</class-id> <category>actions</category><body package="StoreCI-Polling">writeChangesFrom: aFromTimestamp to: aToTimestamp toFile: aFilename revisionStateTo: aStream	knownPundles load.	revisionState		computeWith: [:each | self findChangesIn: each from: aFromTimestamp to: aToTimestamp].	changelog noteDeletedPundles: self deletedPundles.	changelog writeToFile: aFilename.	self writeParcelBuilderInputFile.	revisionState writeOn: aStream.	knownPundles updateWithPundles: revisionState specs</body><body package="StoreCI-Polling">writeRevisionStateTo: aStream	revisionState computeWith: [:each | storeInterface findHeadVersionOf: each].	self writeParcelBuilderInputFile.	revisionState writeOn: aStream</body></methods><methods><class-id>StoreCI.Polling.StoreSCM</class-id> <category>private</category><body package="StoreCI-Polling">writeParcelBuilderInputFile	| ws |	parcelBuilderInputFile ifNil: [^self].	ws := parcelBuilderInputFile writeStream.	[revisionState loadOrder writeOn: ws] ensure: [ws close]</body></methods><methods><class-id>StoreCI.Polling.StoreSCM</class-id> <category>private-changelog</category><body package="StoreCI-Polling">deletedPundles	^knownPundles pundlesMissingFrom: revisionState specs</body><body package="StoreCI-Polling">findChangesIn: aPundleSpec from: fromTimestamp to: toTimestamp	"RevisionState&gt;&gt;computeWith: needs the latest applicable version (head version) of every pundle.	If we find changes, then the most recent version is the head version.  Otherwise, we need to go look	up the head version in the repository."	| changedVersions headRevision |	changedVersions := storeInterface				allChangedVersionsOf: aPundleSpec				from: fromTimestamp				to: toTimestamp.	changelog addPundles: changedVersions.	headRevision := changedVersions isEmpty				ifTrue: [storeInterface findHeadVersionOf: aPundleSpec asOf: toTimestamp]				ifFalse: [changedVersions first].	changelog noteHeadRevision: headRevision.	^headRevision</body></methods><methods><class-id>StoreCI.Polling.StoreSCM class</class-id> <category>instance creation</category><body package="StoreCI-Polling">repository: aConnectionProfile rootPundles: aCollection minimumBlessingLevel: anInteger	^self new		initializeRepository: aConnectionProfile		rootPundles: aCollection		minimumBlessingLevel: anInteger</body></methods><methods><class-id>StoreCI.Polling.RevisionState</class-id> <category>private</category><body package="StoreCI-Polling">enumerateFromBundleComponent: aStorePundle with: aBlock into: aCollection	^self		enumerateFromPundleSpec: aStorePundle asStoreCIPundleSpec versionless		with: aBlock		into: aCollection</body><body package="StoreCI-Polling">enumerateFromPrerequisite: aPrerequisiteDescription with: aBlock into: aCollection	aPrerequisiteDescription canResolveUsingStore ifFalse: [^self].	self		enumerateFromPundleSpec: aPrerequisiteDescription asStoreCIPundleSpec		with: aBlock		into: aCollection</body><body package="StoreCI-Polling">enumerateFromPundleSpec: aPundleSpec with: aBlock into: aCollection	"This is the core of the enumeration algorithm. 	visited is a cache of all pundles already seen; if aPundleSpec has been seen, we can safely skip it.	aBlock is responsible for finding the 'head' version of each pundle.	We first accumulate all prerequisites and bundle components into localRevisions, then add those 	to aCollection at the end.  For bundles, we map the bundle to its localRevisions in bundleRevisions for	later creation of a LoadOrder.	It doesn't much matter if we iterate prerequisites or bundle components first.	However, it is important that each pundle gets added to aCollection after every pundle reachable from it.	That way, aCollection represents an initial cut of a LoadOrder that can be used to safely load all of the 	pundles into a new image without relying on Store to do prerequisite resolution."	| pundle localRevisions |	(visited includes: aPundleSpec) ifTrue: [^self].	visited add: aPundleSpec.	pundle := (aBlock value: aPundleSpec) ifNil: [^self].	localRevisions := OrderedCollection new.	pundle prerequisiteDescriptions		do: [:each | self enumerateFromPrerequisite: each with: aBlock into: localRevisions].	pundle containedItems do: 			[:each |			self enumerateFromBundleComponent: each with: aBlock into: localRevisions].	localRevisions add: pundle.	pundle isBundle ifTrue: [bundleRevisions at: pundle put: localRevisions].	aCollection addAll: localRevisions</body></methods><methods><class-id>StoreCI.Polling.RevisionState</class-id> <category>writing</category><body package="StoreCI-Polling">writeOn: aStream	PundleSpec writeAll: (revisions collect: #asStoreCIPundleSpec) to: aStream</body></methods><methods><class-id>StoreCI.Polling.RevisionState</class-id> <category>private - testing support</category><body package="StoreCI-Polling">bundleRevisions	^bundleRevisions</body></methods><methods><class-id>StoreCI.Polling.RevisionState</class-id> <category>initialize-release</category><body package="StoreCI-Polling">initializeRoots: aCollection	roots := aCollection.	revisions := OrderedCollection new.	bundleRevisions := Dictionary new</body></methods><methods><class-id>StoreCI.Polling.RevisionState</class-id> <category>accessing</category><body package="StoreCI-Polling">computeWith: aBlock	"Using aBlock to find the 'head' version of each pundle reachable from roots, compute the current revision state of the repository.	Along the way, keep track of all not-yet-seen pundles reachable from each bundle."	visited := Set new.	bundleRevisions := Dictionary new.	revisions := roots inject: OrderedCollection new				into: 					[:result :each |					self enumerateFromPundleSpec: each with: aBlock into: result.					result]</body><body package="StoreCI-Polling">loadOrder	"Create a LoadOrder with the information we cached while traversing the pundles."	^LoadOrder allRevisions: revisions copy bundleRevisions: bundleRevisions</body><body package="StoreCI-Polling">specs	"Return a set of PundleSpecs representing the current revision state."	^revisions collect: [:each | each asStoreCIPundleSpec versionless]</body></methods><methods><class-id>StoreCI.Polling.RevisionState class</class-id> <category>enumerating</category><body package="StoreCI-Polling">roots: aCollection	^self new initializeRoots: aCollection</body></methods><methods><class-id>StoreCI.Polling.BlessingNotFound</class-id> <category>printing</category><body package="StoreCI-Polling">description	parameter ifNil: [^super description].	^'Could not find a blessing level named "&lt;1s&gt;"'		expandMacrosWith: parameter</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystem</class-id> <category>private</category><body package="StoreCI-Polling">configuredSCM	| scm |	scm := StoreSCM				repository: repository				rootPundles: rootPundles				minimumBlessingLevel: minimumBlessingLevel.	scm		versionMatcher: versionMatcher;		parcelBuilderInputFile: parcelBuilderInputFile.	^scm</body><body package="StoreCI-Polling">required: anObject option: aString	anObject ifNotNil: [^self].	^ValidationError		raiseErrorString: 'No ' , aString , ' option was specified'</body><body package="StoreCI-Polling">run	| scm |	scm := self configuredSCM.	self shouldComputeChangelog		ifTrue: 			[scm				writeChangesFrom: lastBuildTime				to: currentTime				toFile: changelogFile				revisionStateTo: outputStream]		ifFalse: [scm writeRevisionStateTo: outputStream]</body><body package="StoreCI-Polling">shouldComputeChangelog	^lastBuildTime notNil or: [currentTime notNil or: [changelogFile notNil]]</body><body package="StoreCI-Polling">validateArguments	self shouldComputeChangelog ifFalse: [^self].	self		required: lastBuildTime option: '-since';		required: currentTime option: '-now';		required: changelogFile option: '-changelog'</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystem</class-id> <category>private - test support</category><body package="StoreCI-Polling">minimumBlessingLevel	^minimumBlessingLevel</body><body package="StoreCI-Polling">pundles	^rootPundles</body><body package="StoreCI-Polling">versionMatcher	^versionMatcher</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystem</class-id> <category>accessing</category><body package="StoreCI-Polling">outputStream: aWriteStream	outputStream := aWriteStream</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystem</class-id> <category>initialize/release</category><body package="StoreCI-Polling">clearCachedState	"Subsystem instances live forever in an image, so we need a way to reset the state when loading the image"	super clearCachedState.	repository := nil.	rootPundles := OrderedCollection new.	minimumBlessingLevel := Store.Policies blessingPolicy defaultBlessing.	outputStream := Stdout.	parcelBuilderInputFile := nil.	versionMatcher := nil.	lastBuildTime := nil.	currentTime := nil.	changelogFile := nil</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystem</class-id> <category>testing</category><body package="StoreCI-Polling">isReadyToRun	^repository notNil and: [rootPundles notEmpty]</body></methods><methods><class-id>StoreCI.Polling.LoadOrder</class-id> <category>writing</category><body package="StoreCI-Polling">writeOn: aStream	PundleSpec writeAll: (revisions collect: #asStoreCIPundleSpec) to: aStream</body></methods><methods><class-id>StoreCI.Polling.LoadOrder</class-id> <category>private - testing support</category><body package="StoreCI-Polling">revisions	^revisions</body></methods><methods><class-id>StoreCI.Polling.LoadOrder</class-id> <category>private</category><body package="StoreCI-Polling">adjustRevisions: revisionsCollection forBundle: aStoreBundle bundleRevisions: bundleRevisionCollection	"Remove all of aStoreBundle's components from revisionsCollection in a way that preserves the correctness of the load order.	This is done by moving aStoreBundle and its recursive prerequisites (found in bundleRevisionCollection) forward in the list to	the position of the earliest of its components (called 'pivot' in the code)."	| bundleComponents pivot first rest replacements |	bundleComponents := aStoreBundle containedItems.	pivot := revisionsCollection				findFirst: [:each | bundleComponents includes: each].	pivot isZero ifTrue: [^self].	first := revisionsCollection copyFrom: 1 to: pivot - 1.	replacements := self removeAll: first from: bundleRevisionCollection.	rest := self removeAll: replacements				from: (revisionsCollection copyFrom: pivot + 1 to: revisionsCollection size).	^self removeAll: bundleComponents from: first , replacements , rest</body><body package="StoreCI-Polling">removeAll: toRemoveCollection from: mainCollection	^mainCollection		reject: [:each | toRemoveCollection includes: each]</body></methods><methods><class-id>StoreCI.Polling.LoadOrder</class-id> <category>initialize-release</category><body package="StoreCI-Polling">initializeAllRevisions: aCollection bundleRevisions: aDictionary	"Compute the revisions in load order by adjusting all of the bundles in aCollection using the information in aDictionary."	revisions := (aCollection select: #isBundle)				inject: (OrderedCollection withAll: aCollection)				into: 					[:adjusted :each |					self						adjustRevisions: adjusted						forBundle: each						bundleRevisions: (aDictionary at: each ifAbsent: [OrderedCollection new])]</body></methods><methods><class-id>StoreCI.Polling.LoadOrder class</class-id> <category>instance creation</category><body package="StoreCI-Polling">allRevisions: aCollection bundleRevisions: aDictionary	^self new initializeAllRevisions: aCollection bundleRevisions: aDictionary</body></methods><methods><class-id>StoreCI.Polling.StoreInterface</class-id> <category>initialize-release</category><body package="StoreCI-Polling">initializeProfile: aConnectionProfile minimumBlessingLevel: aBlessingLevel	session := StoreLoginFactory sessionForStoreLogin: aConnectionProfile.	minimumBlessingLevel := aBlessingLevel</body><body package="StoreCI-Polling">versionMatcher: anRxMatcher	versionMatcher := anRxMatcher</body></methods><methods><class-id>StoreCI.Polling.StoreInterface</class-id> <category>queries</category><body package="StoreCI-Polling">allChangedVersionsOf: aPundleSpec from: fromTimestamp to: toTimestamp	"Find all versions of the pundle represented by aPundleSpec 	that changed between fromTimestamp and toTimestamp.	Ignore pundles with too low a blessing level, and those whose versions don't match our versionMatcher.	Include pundles whose only relevant change was a blessing change."	| query results |	query := Glorp.Query readManyOf: aPundleSpec pundleType				where: 					[:each |					each name = aPundleSpec name						AND: each currentBlessingLevel &gt;= minimumBlessingLevel].	query alsoFetch: [:each | each blessings].	query orderBy: [:each | each timestamp descending].	results := session execute: query.	^results select: 			[:each |			(self isVersionOfInterest: each version) and: 					[(each timestamp between: fromTimestamp and: toTimestamp) or: 							[each blessings								anySatisfy: [:eachBlessing | eachBlessing timestamp between: fromTimestamp and: toTimestamp]]]]</body><body package="StoreCI-Polling">findHeadVersionOf: aPundleSpec	^self findHeadVersionOf: aPundleSpec asOf: Timestamp nowUTC</body></methods><methods><class-id>StoreCI.Polling.StoreInterface</class-id> <category>private</category><body package="StoreCI-Polling">isVersionOfInterest: aString	"If no version matcher was provided, then match all versions."	^versionMatcher isNil or: [versionMatcher matches: aString]</body><body package="StoreCI-Polling">pundleNotFound: aPundleSpec	^nil</body></methods><methods><class-id>StoreCI.Polling.StoreInterface</class-id> <category>private-queries</category><body package="StoreCI-Polling">findHeadVersionOf: aPundleSpec asOf: aTimestamp	"Find the latest version of the pundle represented by aPundleSpec as of aTimestamp.	Ignore pundles with too low a blessing level and those whose version doesn't match our version matcher."	| query result matching |	query := Glorp.Query readManyOf: aPundleSpec pundleType				where: [:each | each name = aPundleSpec name].	query orderBy: [:each | each timestamp descending].	query retrieve: [:each | each currentBlessingLevel].	query retrieve: [:each | each version].	query retrieve: [:each | each timestamp].	result := session execute: query.	matching := result detect: 					[:each |					each first &gt;= minimumBlessingLevel						and: [(self isVersionOfInterest: (each at: 2)) and: [each last &lt;= aTimestamp]]]				ifNone: [^self pundleNotFound: aPundleSpec].	query := Glorp.Query readOneOf: aPundleSpec pundleType				where: 					[:each |					each name = aPundleSpec name						AND: each version = (matching at: 2)						AND: each currentBlessingLevel = matching first						AND: each timestamp = matching last].	^session execute: query</body></methods><methods><class-id>StoreCI.Polling.StoreInterface class</class-id> <category>instance creation</category><body package="StoreCI-Polling">connectionProfile: aConnectionProfile minimumBlessingLevel: aBlessingLevel	^self new initializeProfile: aConnectionProfile		minimumBlessingLevel: aBlessingLevel</body></methods><methods><class-id>StoreCI.Polling.PollingSubsystem</class-id> <category>command line</category><body package="StoreCI-Polling">bundles: aStream	&lt;option: '-bundle'&gt;	&lt;option: '-bundles'&gt;	rootPundles addAll: ((CommandLineInterest argumentsFrom: aStream)				collect: [:each | PundleSpec forBundle: each])</body><body package="StoreCI-Polling">changelogFile: aStream	&lt;option: '-changelog'&gt;	changelogFile := aStream next asFilename</body><body package="StoreCI-Polling">currentTime: aStream	&lt;option: '-now'&gt;	currentTime := Timestamp readFrom: aStream next readStream</body><body package="StoreCI-Polling">lastBuildTime: aStream	&lt;option: '-since'&gt;	lastBuildTime := Timestamp readFrom: aStream next readStream</body><body package="StoreCI-Polling">minimumBlessingLevel: aStream	&lt;option: '-blessedAtLeast'&gt;	| blessing |	blessing := aStream next.	minimumBlessingLevel := (Store.Policies blessingPolicy blessingNumber: blessing)				ifNil: [^BlessingNotFound raiseWith: blessing]</body><body package="StoreCI-Polling">packages: aStream	&lt;option: '-package'&gt;	&lt;option: '-packages'&gt;	rootPundles addAll: ((CommandLineInterest argumentsFrom: aStream)				collect: [:each | PundleSpec forPackage: each])</body><body package="StoreCI-Polling">parcelBuilderInputFile: aStream	&lt;option: '-parcelBuilderFile'&gt;	parcelBuilderInputFile := aStream next asFilename</body><body package="StoreCI-Polling">repository: aStream	&lt;option: '-repository'&gt;	repository := self repositoryNamed: aStream next</body><body package="StoreCI-Polling">versionRegex: aStream	&lt;option: '-versionRegex'&gt;	versionMatcher := aStream next asRegex</body></methods><methods><class-id>Store.Glorp.StoreBundle class</class-id> <category>accessing</category><body package="StoreCI-Polling">storeCIElementTag	^'bundle'</body></methods><methods><class-id>Store.Glorp.StoreBlessing</class-id> <category>converting</category><body package="StoreCI-Polling">asXMLElementForStoreCI	| formattedTimestamp |	formattedTimestamp := ((Locale named: #C) printAsTime: self timestamp				policyNamed: #editing) asString.	^(Element tag: 'blessing')		addAttribute: (Attribute name: 'user' value: self username);		addAttribute: (Attribute name: 'timestamp' value: formattedTimestamp);		addNode: (XML.Text text: self comment);		yourself</body></methods><methods><class-id>Store.Glorp.StorePundle class</class-id> <category>accessing</category><body package="StoreCI-Polling">storeCIElementTag	^self subclassResponsibility</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>converting</category><body package="StoreCI-Polling">asXMLElementForStoreCI	| element |	element := (Element tag: self class storeCIElementTag)				addAttribute: (Attribute name: 'name' value: self name);				addAttribute: (Attribute name: 'version' value: self version);				yourself.	(self blessings asSortedCollection: [:a :b | a timestamp &gt;= b timestamp])		do: [:each | element addNode: each asXMLElementForStoreCI].	^element</body></methods><methods><class-id>StoreCI.Support.PundleSpec</class-id> <category>private</category><body package="StoreCI-Polling">asXMLElementForStoreCI	| element |	element := Element tag: pundleType storeCIElementTag.	element addAttribute: (Attribute name: 'name' value: self name).	^element</body></methods><methods><class-id>Store.Glorp.StorePackage class</class-id> <category>accessing</category><body package="StoreCI-Polling">storeCIElementTag	^'package'</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>PundleSpec</name><environment>StoreCI.Support</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleType name version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Support</package></attributes></class><class><name>StorePundle</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreSourceObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment properties propertiesBlob propertiesRecordDictionary version blessings currentBlessingLevel storeModel session versionless fullClasses </inst-vars><class-inst-vars>cache </class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Database Model</package></attributes></class><class><name>StoreCISubsystem</name><environment>StoreCI.Support</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>debug errorStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>StoreCI-Support</package></attributes></class><class><name>StoreBlessing</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timestamp username comment blessingLevel trace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreForGlorp</category><attributes><package>Store-Database Model</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>